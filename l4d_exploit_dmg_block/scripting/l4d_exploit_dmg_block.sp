/**
 * SourceMod is licensed under the GNU General Public License, version 3.  
 */

#pragma semicolon 1
#pragma newdecls required

#include <sourcemod>
#include <sdktools>
#include <sdkhooks>
#include <left4dhooks>      // https://forums.alliedmods.net/showthread.php?t=321696

#define PLUGIN_VERSION			"1.0-2025/7/25"
#define PLUGIN_NAME			    "l4d_exploit_dmg_block"
#define DEBUG 0

public Plugin myinfo =
{
	name = "[L4D1/2] l4d_exploit_dmg_block",
	author = "HarryPotter",
	description = "Block exploit damage by player, ex: throw molotov and change team to infected",
	version = PLUGIN_VERSION,
	url = "https://steamcommunity.com/profiles/76561198026784913/"
};

bool g_bL4D2Version, bLate;
int ZC_TANK;
public APLRes AskPluginLoad2(Handle myself, bool late, char[] error, int err_max)
{
    EngineVersion test = GetEngineVersion();

    if( test == Engine_Left4Dead )
    {
        g_bL4D2Version = false;
        ZC_TANK = 5;
    }
    else if( test == Engine_Left4Dead2 )
    {
        g_bL4D2Version = true;
        ZC_TANK = 8;
    }
    else
    {
        strcopy(error, err_max, "Plugin only supports Left 4 Dead 1 & 2.");
        return APLRes_SilentFailure;
    }

    bLate = late;
    return APLRes_Success;
}

#define CVAR_FLAGS                    FCVAR_NOTIFY
#define CVAR_FLAGS_PLUGIN_VERSION     FCVAR_NOTIFY|FCVAR_DONTRECORD|FCVAR_SPONLY

#define MAXENTITIES                   2048

#define MODEL_GASCAN                  "models/props_junk/gascan001a.mdl"
#define MODEL_PROPANECANISTER         "models/props_junk/propanecanister001a.mdl"
#define MODEL_OXYGENTANK              "models/props_equipment/oxygentank01.mdl"
#define MODEL_FIREWORKS_CRATE         "models/props_junk/explosive_box001.mdl"

static int   	g_iModel_Gascan = -1;
static int    	g_iModel_PropaneCanister = -1;
static int    	g_iModel_OxygenTank = -1;
static int    	g_iModel_FireworksCrate = -1;

ConVar g_hCvarEnable;
bool g_bCvarEnable;

enum struct CEnt
{
    int m_iUserId;
    int m_iTeam;
    bool m_bWasPlayer;

    void Reset()
    {
        this.m_iUserId = 0;
        this.m_iTeam = 0;
        this.m_bWasPlayer = false;
    }
}

CEnt
    g_cEnt[MAXENTITIES+1];

int 
    g_iMolotovProjectileRef = -1;

public void OnPluginStart()
{
    g_hCvarEnable 		= CreateConVar( PLUGIN_NAME ... "_enable",        "1",   "0=Plugin off, 1=Plugin on.", CVAR_FLAGS, true, 0.0, true, 1.0);
    CreateConVar(                       PLUGIN_NAME ... "_version",       PLUGIN_VERSION, PLUGIN_NAME ... " Plugin Version", CVAR_FLAGS_PLUGIN_VERSION);
    AutoExecConfig(true,                PLUGIN_NAME);

    GetCvars();
    g_hCvarEnable.AddChangeHook(ConVarChanged_Cvars);

    if(bLate)
    {
        LateLoad();
    }
}

void LateLoad()
{
    for (int client = 1; client <= MaxClients; client++)
    {
        if (!IsClientInGame(client))
            continue;

        OnClientPutInServer(client);
    }
}

// Cvars-------------------------------

void ConVarChanged_Cvars(ConVar hCvar, const char[] sOldVal, const char[] sNewVal)
{
	GetCvars();
}

void GetCvars()
{
    g_bCvarEnable = g_hCvarEnable.BoolValue;
}

// Sourcemod API Forward-------------------------------

public void OnMapStart()
{
    g_iModel_Gascan = PrecacheModel(MODEL_GASCAN, true);
    g_iModel_PropaneCanister = PrecacheModel(MODEL_PROPANECANISTER, true);
    g_iModel_OxygenTank = PrecacheModel(MODEL_OXYGENTANK, true);

    if(g_bL4D2Version)
    {
        g_iModel_FireworksCrate = PrecacheModel(MODEL_FIREWORKS_CRATE, true);
    }
}

public void OnClientPutInServer(int client)
{
	SDKHook(client, SDKHook_OnTakeDamage, OnTakeDamage_Client);
}

public void OnEntityCreated(int entity, const char[] classname)
{
    if (!g_bCvarEnable || !IsValidEntityIndex(entity))
        return;

    switch (classname[0])
    {
        case 'p':
        {
            if (StrEqual(classname, "pipe_bomb_projectile"))
            {
                g_cEnt[entity].Reset();
                SDKHook(entity, SDKHook_SpawnPost, OnEffectSpawnPost_pipe_bomb_projectile);
            }
            else if (strncmp(classname, "prop_physics", 12, false) == 0
                || strncmp(classname, "physics_prop", 12, false) == 0)
            {
                RequestFrame(OnFramePhysicsSpawn, EntIndexToEntRef(entity)); // Delay to get modelname and test if valid entity, otherwise unhook
            }
            else if (strncmp(classname, "prop_fuel_barrel", 16, false) == 0)
            {
                g_cEnt[entity].Reset();
                SDKHook(entity, SDKHook_OnTakeDamage, PropOnTakeDamage);
            }
        }
        case 'w':
        {
            if (strncmp(classname, "weapon_gascan", 13, false) == 0
                || strncmp(classname, "weapon_oxygentank", 17, false) == 0
                || strncmp(classname, "weapon_propanetank", 18, false) == 0
                || (g_bL4D2Version && strncmp(classname, "weapon_fireworkcrate", 20, false) == 0) )
            {
                g_cEnt[entity].Reset();
                SDKHook(entity, SDKHook_OnTakeDamage, PropOnTakeDamage);
            }
        }
        case 'g':
        {
            if (g_bL4D2Version && StrEqual(classname, "grenade_launcher_projectile"))
            {
                g_cEnt[entity].Reset();
            }
        }
        case 'i':
        {
            // 丟火瓶或汽油桶產生的火焰
            if (StrEqual(classname, "inferno"))
            {
                g_cEnt[entity].Reset();
                SDKHook(entity, SDKHook_SpawnPost, OnEffectSpawnPost_inferno);
            }
        }
        case 'e':
        {
            // 玩家著火才會有entityflame
            if (StrEqual(classname, "entityflame"))
            {
                g_cEnt[entity].Reset();
                SDKHook(entity, SDKHook_SpawnPost, OnEffectSpawnPost_entityflame);
            }
        }
        case 'f':
        {
            // 煙火盒
            if (g_bL4D2Version && StrEqual(classname, "fire_cracker_blast"))
            {
                g_cEnt[entity].Reset();
                SDKHook(entity, SDKHook_SpawnPost, OnEffectSpawnPost_fire_cracker_blast);
            }
        }
    }
}

// SDKHooks-------------------------------

Action OnTakeDamage_Client(int victim, int &attacker, int &inflictor, float &damage, int &damagetype, int &weapon, float damageForce[3], float damagePosition[3], int damagecustom)
{
    if (!g_bCvarEnable || !IsValidEntity(inflictor)) return Plugin_Continue;
    int team = GetClientTeam(victim);
    if (team <= L4D_TEAM_SPECTATOR || !IsPlayerAlive(victim)) return Plugin_Continue;
    
    if (team == L4D_TEAM_SURVIVOR)
    {
        if (g_cEnt[inflictor].m_bWasPlayer)
        {
            static char sClassName[64];
            GetEntityClassname(inflictor, sClassName, sizeof(sClassName));
            //PrintToChatAll("OnTakeDamage_Client: %d (%s)", inflictor, inflictor);
            if(strcmp(sClassName, "pipe_bomb_projectile", false) == 0
                || (g_bL4D2Version && strcmp(sClassName, "grenade_launcher_projectile", false) == 0) )
            {
                int owner = GetClientOfUserId(g_cEnt[inflictor].m_iUserId);
                if(!owner || !IsClientInGame(owner))
                {
                    return Plugin_Handled;
                }

                if(GetClientTeam(owner) != L4D_TEAM_SURVIVOR && !IsClientIdle(owner))
                {
                    return Plugin_Handled;
                }
            }
            else if(strcmp(sClassName, "inferno", false) == 0
                || strcmp(sClassName, "entityflame", false) == 0
                || (g_bL4D2Version && strcmp(sClassName, "fire_cracker_blast", false) == 0) )
            {
                int owner = GetClientOfUserId(g_cEnt[inflictor].m_iUserId);
                if(!owner || !IsClientInGame(owner))
                {
                    return Plugin_Handled;
                }

                if(GetClientTeam(owner) != L4D_TEAM_SURVIVOR && !IsClientIdle(owner))
                {
                    return Plugin_Handled;
                }
            }
            /*else if(strcmp(sClassName, "tank_rock", false) == 0)
            {
                int owner = GetClientOfUserId(g_cEnt[inflictor].m_iUserId);
                if(!owner || !IsClientInGame(owner))
                {
                    return Plugin_Handled;
                }

                if(GetClientTeam(owner) != L4D_TEAM_INFECTED)
                {
                    return Plugin_Handled;
                }
            }*/
        }
        else
        {
            // 噴酸液的時候變成tank
            if(attacker > 0 && attacker <= MaxClients && IsClientInGame(attacker) && GetClientTeam(attacker) == L4D_TEAM_INFECTED && GetEntProp(attacker, Prop_Send, "m_zombieClass") == ZC_TANK && IsPlayerAlive(attacker))
            {
                static char sClassName[64];
                GetEntityClassname(inflictor, sClassName, sizeof(sClassName));
                if(strcmp(sClassName, "insect_swarm", false) == 0)
                {
                    attacker = inflictor;
                    return Plugin_Changed;
                }
            }
        }
    }
    
    return Plugin_Continue;
}

Action PropOnTakeDamage(int prop, int &attacker, int &inflictor, float &damage, int &damagetype, int &weapon, float damageForce[3], float damagePosition[3], int damagecustom)
{
    if (!g_bCvarEnable || !IsValidEntity(inflictor)) return Plugin_Continue;
    
    if (g_cEnt[inflictor].m_bWasPlayer)
    {
        static char sClassName[64];
        GetEntityClassname(inflictor, sClassName, sizeof(sClassName));
        if(strcmp(sClassName, "pipe_bomb_projectile", false) == 0
            || (g_bL4D2Version && strcmp(sClassName, "grenade_launcher_projectile", false) == 0) )
        {
            int owner = GetClientOfUserId(g_cEnt[inflictor].m_iUserId);
            if(!owner || !IsClientInGame(owner))
            {
                return Plugin_Handled;
            }

            if(GetClientTeam(owner) != L4D_TEAM_SURVIVOR && !IsClientIdle(owner))
            {
                return Plugin_Handled;
            }
        }
        else if(strcmp(sClassName, "inferno", false) == 0
            || strcmp(sClassName, "entityflame", false) == 0
            || (g_bL4D2Version && strcmp(sClassName, "fire_cracker_blast", false) == 0) )
        {
            int owner = GetClientOfUserId(g_cEnt[inflictor].m_iUserId);
            if(!owner || !IsClientInGame(owner))
            {
                return Plugin_Handled;
            }

            if(GetClientTeam(owner) != L4D_TEAM_SURVIVOR && !IsClientIdle(owner))
            {
                return Plugin_Handled;
            }
        }
    }
    else
    {
        
    }

    return Plugin_Continue;
}

// Timer & Frame-------------------------------

void OnEffectSpawnPost_pipe_bomb_projectile(int entity)
{
    if(!IsValidEntity(entity)) return;

    // 土製炸彈
    if(g_cEnt[entity].m_bWasPlayer) return;

    GetEntInfo(entity);
}

void OnEffectSpawnPost_inferno(int entity)
{
    if(!IsValidEntity(entity)) return;

    int MolotovProjectile = EntRefToEntIndex(g_iMolotovProjectileRef);
    g_iMolotovProjectileRef = -1;
    if(MolotovProjectile != INVALID_ENT_REFERENCE)
    {
        g_cEnt[entity] = g_cEnt[MolotovProjectile];
        return;
    }

    GetEntInfo(entity);
}

void OnEffectSpawnPost_entityflame(int entity)
{
    if(!IsValidEntity(entity)) return;

    GetEntInfo(entity);
}

void OnEffectSpawnPost_fire_cracker_blast(int entity)
{
    if(!IsValidEntity(entity)) return;

    GetEntInfo(entity);
}

void OnFramePhysicsSpawn(int entity)
{
    entity = EntRefToEntIndex(entity);

    if( EntRefToEntIndex(entity) == INVALID_ENT_REFERENCE ) return;
    
    int modelIndex = GetEntProp(entity, Prop_Send, "m_nModelIndex");
    if( modelIndex == g_iModel_Gascan 
        || modelIndex == g_iModel_PropaneCanister
        || modelIndex == g_iModel_OxygenTank
        || (g_bL4D2Version && modelIndex == g_iModel_FireworksCrate) ) 
    {
        g_cEnt[entity].Reset();
        SDKHook(entity, SDKHook_OnTakeDamage, PropOnTakeDamage);
    }
}

// API---------------

public void L4D_PipeBombProjectile_Post(int client, int projectile, const float vecPos[3], const float vecAng[3], const float vecVel[3], const float vecRot[3])
{
    if(!g_bCvarEnable || projectile <= 0) return;

    if(client <= 0 || !IsClientInGame(client) || IsFakeClient(client)) return;

    int team = GetClientTeam(client); 
    if(team != L4D_TEAM_SURVIVOR) return;

    g_cEnt[projectile].m_iUserId = GetClientUserId(client);
    g_cEnt[projectile].m_iTeam = team;
    g_cEnt[projectile].m_bWasPlayer = true;
}

public Action L4D_PipeBomb_Detonate(int entity, int client)
{
    if(!g_bCvarEnable || entity <= 0
        || !g_cEnt[entity].m_bWasPlayer)
    {
        return Plugin_Continue;
    }

    /*int owner = GetClientOfUserId(g_cEnt[entity].m_iUserId);
    if(!owner || !IsClientInGame(owner))
    {
        RemoveEntity(entity);
        return Plugin_Handled;
    }

    if(GetClientTeam(owner) != L4D_TEAM_SURVIVOR && !IsClientIdle(owner))
    {
        RemoveEntity(entity);
        return Plugin_Handled;
    }*/

    return Plugin_Continue;
}

public void L4D_MolotovProjectile_Post(int client, int projectile, const float vecPos[3], const float vecAng[3], const float vecVel[3], const float vecRot[3])
{
    if(!g_bCvarEnable || projectile <= 0) return;

    if(client <= 0 || !IsClientInGame(client) || IsFakeClient(client)) return;

    int team = GetClientTeam(client); 
    if(team != L4D_TEAM_SURVIVOR) return;

    g_cEnt[projectile].m_iUserId = GetClientUserId(client);
    g_cEnt[projectile].m_iTeam = team;
    g_cEnt[projectile].m_bWasPlayer = true;
}

public Action L4D_Molotov_Detonate(int entity, int client)
{
    if(!g_bCvarEnable || entity <= 0
        || !g_cEnt[entity].m_bWasPlayer)
    {
        return Plugin_Continue;
    }

    /*int owner = GetClientOfUserId(g_cEnt[entity].m_iUserId);
    if(!owner || !IsClientInGame(owner))
    {
        RemoveEntity(entity);
        return Plugin_Handled;
    }

    if(GetClientTeam(owner) != L4D_TEAM_SURVIVOR && !IsClientIdle(owner))
    {
        RemoveEntity(entity);
        return Plugin_Handled;
    }*/

    g_iMolotovProjectileRef = EntIndexToEntRef(entity);
    //PrintToChatAll("L4D_Molotov_Detonate: %d", GetGameTickCount());

    return Plugin_Continue;
}

public void L4D_Molotov_Detonate_PostHandled(int entity, int client)
{
    g_iMolotovProjectileRef = -1;
}

public void L4D2_GrenadeLauncherProjectile_Post(int client, int projectile, const float vecPos[3], const float vecAng[3], const float vecVel[3], const float vecRot[3])
{
    if(!g_bCvarEnable || projectile <= 0) return;

    if(client <= 0 || !IsClientInGame(client) || IsFakeClient(client)) return;

    int team = GetClientTeam(client); 
    if(team != L4D_TEAM_SURVIVOR) return;

    g_cEnt[projectile].m_iUserId = GetClientUserId(client);
    g_cEnt[projectile].m_iTeam = team;
    g_cEnt[projectile].m_bWasPlayer = true;
}

public Action L4D2_GrenadeLauncher_Detonate(int entity, int client)
{
    if(!g_bCvarEnable || entity <= 0
        || !g_cEnt[entity].m_bWasPlayer)
    {
        return Plugin_Continue;
    }

    /*int owner = GetClientOfUserId(g_cEnt[entity].m_iUserId);
    if(!owner || !IsClientInGame(owner))
    {
        RemoveEntity(entity);
        return Plugin_Handled;
    }

    if(GetClientTeam(owner) != L4D_TEAM_SURVIVOR && !IsClientIdle(owner))
    {
        RemoveEntity(entity);
        return Plugin_Handled;
    }*/

    return Plugin_Continue;
}
/*
public void L4D_TankRock_OnRelease_Post(int tank, int rock, const float vecPos[3], const float vecAng[3], const float vecVel[3], const float vecRot[3])
{
    if(!g_bCvarEnable || rock <= 0) return;

    if(tank <= 0 || !IsClientInGame(tank) || IsFakeClient(tank)) return;

    int team = GetClientTeam(tank); 
    if(team != L4D_TEAM_INFECTED || GetEntProp(tank, Prop_Send, "m_zombieClass") != ZC_TANK || !IsPlayerAlive(tank)) return;

    g_cEnt[rock].m_iUserId = GetClientUserId(tank);
    g_cEnt[rock].m_iTeam = team;
    g_cEnt[rock].m_bWasPlayer = true;
}*/

// Others-------------------------------

void GetEntInfo(int entity)
{
    int client = GetEntPropEnt(entity, Prop_Data, "m_hOwnerEntity");
    if(client <= 0 || client > MaxClients || !IsClientInGame(client) || IsFakeClient(client)) return;

    int team = GetClientTeam(client); 
    if(team != L4D_TEAM_SURVIVOR) return;

    g_cEnt[entity].m_iUserId = GetClientUserId(client);
    g_cEnt[entity].m_iTeam = team;
    g_cEnt[entity].m_bWasPlayer = true;
}

bool IsValidEntityIndex(int entity)
{
    return (MaxClients+1 <= entity <= GetMaxEntities());
} 

bool IsClientIdle(int client)
{
	if(GetClientTeam(client) != L4D_TEAM_SPECTATOR)
		return false;
	
	for(int i = 1; i <= MaxClients; i++)
	{
		if(IsClientInGame(i) && IsFakeClient(i) && GetClientTeam(i) == L4D_TEAM_SURVIVOR && IsPlayerAlive(i))
		{
			if(HasEntProp(i, Prop_Send, "m_humanSpectatorUserID"))
			{
				if(GetClientOfUserId(GetEntProp(i, Prop_Send, "m_humanSpectatorUserID")) == client)
						return true;
			}
		}
	}
	return false;
}